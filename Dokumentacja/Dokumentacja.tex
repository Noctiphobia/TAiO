\documentclass{article}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{indentfirst}
\usepackage{float}
\title{Dokumentacja projektu dotyczącego optymalnego układania klocków na planszy}
\author{Abdelkarim Ahmed, Cacko Agata, Hernik Aleksandra}
\begin{document}
\maketitle
\section{Opis projektu}
\section{Opis algorytmu}
Wykorzystany algorytm jest algorytmem zachłannym z określoną parametrem liczbą nawrotów $k$. W każdym kroku algorytmu uruchamiane jest $k'$, gdzie $1 \le k' \le k$ (w sekcji wielowątkowość znajduje się wyjaśnienie, od czego jest uzależniona ich dokładna liczba). Każdemu wątkowi odpowiada jeden z $k$ najlepszych wyników uzyskanych w poprzednim kroku, gdzie najlepszy wynik to taki, dla którego wartość funkcji kosztu jest jak najmniejsza -- każdy z nich dla swoich danych wejściowych znajduje $k$ najlepszych rozwiązań. Znalezienie rozwiązań polega na sprawdzeniu dla każdego klocka każdego jego rotacji -- najpierw wybierana jest jego pozycja, a następnie liczony koszt całej planszy. $k$ rozwiązań takich, że funkcja kosztu obliczona na planszy z położonym danym klockiem w danej rotacji jest najmniejsza, to rozwiązanie dla danego wątku. Następnie, spośród ułożeń otrzymanych przez wszystkie wątki ($1 \le k' \le k$, zatem otrzymywane jest od $k$ do $k^2$ ułożeń) wybierane jest $k$ najlepszych. Ogólny schemat działania algorytmu podsumowuje poniższy diagram:
\begin{figure}[H]
\includegraphics[width=\textwidth]{schemat_algorytmu.png}
\caption{Ogólny schemat działania algorytmu}
\end{figure}
\subsection{Wybór pozycji dla klocka}
\subsection{Funkcje kosztu planszy}
\subsection{Wielowątkowość}
W celu przyspieszenia działania algorytmu, do wykonywania niezależnych od siebie obliczeń wykorzystywany jest mechanizm wątków. W tym przypadku takimi obliczeniami jest szukanie $k$ najlepszych rozwiązań dla danej planszy. W każdym kroku tworzone jest $k'$ wątków, gdzie $1 \le k' \le k$, a w większości przypadków $k'=k$. 

Pierwszym ze szczególnych przypadków jest pierwszy krok - ponieważ jest tylko jedno wcześniejsze ułożenie (pusta plansza), uruchamiany jest tylko jeden wątek -- gdyby było uruchomione k wątków, każdy z nich znalazł by te same rozwiązania i w efekcie algorytm wybrałby najlepsze rozwiązanie z każdego wątku -- czyli wynikiem pierwszego kroku byłoby k identycznych ułożeń. Dzięki uruchomieniu tylko jednego wątku, znajdowane jest k różnych ułożeń, a ponadto, szczególnie dla dużych k, wykonuje się on szybciej. 

Drugi przypadek jest efektem dodatkowego usprawnienia algorytmu, który ma na celu eliminowanie identycznych rozwiązań, w celu sprawdzenia jak największej liczby możliwości. Polega ono na tym, że po każdym kroku sprawdzana jest unikalność rozwiązań -- sprawdzany jest najpierw ostatni położony klocek (współrzędne, w których został położony, obrót i identyfikator). Jeśli wykryty zostanie jakikolwiek konflikt, dokonywane jest porównanie plansz wynikowych. W przypadku, gdy plansze również są identyczne, pozostawiane jest tylko jedno z tych rozwiązań -- bo identyczne plansze dają identyczne rozwiązania, więc dopóki jakieś rozwiązanie pochodzące z tej planszy byłoby jednym z $k$ najlepszych istniejących, dwa wątki wykonywałyby dokładnie te same operacje. W ten sposób do następnego kroku może trafić zredukowana liczba plansz wejściowych, ale krok później, o ile znowu nie występowały powtórzenia, algorytm stabilizuje liczbę wątków na $k$. Koszt takiego rozwiązania jest niewielki -- porównanie wstępne jest realizowane w czasie stałym (liczba porównań jest rzędu $k^2$, gdzie $k$ to stała, a porównanie ułożenia klocka to cztery porównania liczb całkowitych), więc jeśli problem nie wystąpi, algorytm nie działa zauważalnie wolniej. Liczba sytuacji, w których trzeba wykonać dodatkowe sprawdzenie, powinna być bardzo niewielka, a eliminacja identycznych rozwiązań eliminuje jednakowe obliczenia, które mogłyby ciągnąć się nawet do samego końca -- efektywnie algorytm działałby od pewnego momentu tak, jakby wartość $k$ została zmniejszona.

Po zwróceniu przez każdy z $k$ wątków listy $k$ najlepszych rozwiązań trzeba wybrać k najlepszych rozwiązań z otrzymanych $k^2$.  
Wynikowe elementy są wybierane przez k-krotny wybór największego elementu z list.
Korzystamy tu z faktu, że zwrócone listy są posortowane po wartości funkcji kosztu.
Dzięki temu wystarczy sprawdzić tylko najmniejszy niewykorzystany element z każdej listy (w czasie $k$), zamiast przeglądać wszystkie elementy wszystkich list (w czasie $k^2$).
\subsection{Struktura danych}
\section{Testy}
\subsection{Zestaw 100 klocków 4x3, 5x3, 5x4, 6x4 o polu co najwyżej 8}
Na tym standardowym zestawie klocków zostanie dokonana dokładna analiza własności naszego algorytmu z uwzględnieniem różnej liczby rozgałęzień, szerokości studni i wszystkich udostępnionych funkcji kosztu.

\subsubsection{Szerokość studni: 5}
\begin{enumerate}
\item Funkcja minimalizująca dziury

Gęstość dla $k=3$: 71

Najlepsza gęstość dla $k=5$: 71

Dla podanych parametrów można zauważyć ciekawe zachowanie. 
Wbrew oczekiwaniom zwiększaniu liczby rozgałęzień nie towarzyszy poprawa wyników. 
Najlepszy wynik wystąpił dla $k=5$ i $k=10$ przy znacznie niższych wartościach dla wartości pomiędzy. W
ynika to ze specyfiki zastosowanego algorytmu, będącego algorytmem zachłannym. 
Na przykład dla $k=4$ w trakcie obliczeń mogło pojawić się ułożenie, które w danym momencie wydawało się bardziej obiecujące, niż wszystkie ułożenia dla $k=3$, jednak ostatecznie okazało się mniej korzystne.
Podobny efekt można zaobserwować dla pozostałych funkcji.

\begin{figure}[H]
\includegraphics[width=\textwidth]{k_plot.png}
\caption{Wykres gęstości od liczby rozgałęzień}
\end{figure}

\item Funkcja minimalizująca wysokość

Gęstość dla $k=3$: 71

Najlepsza gęstość dla $k=10$: 75

Funkcja wysokości, nie najlepiej sprawdzająca się w większości przypadków, przy wąskiej studni radzi sobie porównywalnie z pozostałymi.

\item Funkcja maksymalizująca przyleganie

Gęstość dla $k=3$: 70

Najlepsza gęstość dla $k=7$: 76

Jest to najlepsza funkcja dla tego przypadku - dobry rezultat udało się osiągnąć przy stosunkowo małej wartości k.
\end{enumerate}
\subsubsection{Szerokość studni: 20}
Szerokość 20 jest najlepsza do porównania funkcji kosztu, a także zaobserwowania ich szczególnych cech.
Pozwala na większą swobodę ułożenia klocków niż szerokość 5, a jednocześnie wynikowa wysokość jest na tyle duża, że nierówności na górze nie mają istotnego wpływu na gęstość.
\begin{enumerate}
\item Funkcja minimalizująca dziury

Gęstość dla $k=3$: 75

Najlepsza gęstość dla $k=9$: 80

Na rysunku można zaobserwować pewną wadę tej funkcji - pozwala na tworzenie głębokich, wąskich dziur (jak na górze po lewej). 
Wynika to z tego, że takie zjawisko nie jest traktowane przez funkcję jako dziura.
Z kolei zakrycie takiej dziury klockiem znacząco zwiększa liczbę dziur, więc algorytm pozwoli na to tylko w ostateczności.

\begin{figure}[H]
\includegraphics[width=\textwidth]{dziury.PNG}
\caption{Ułożenie klocków dla funkcji dziur}
\end{figure}

\item Funkcja minimalizująca wysokość

Gęstość dla $k=3$: 72

Najlepsza gęstość dla $k=10$: 76

W przypadku funkcji wysokości można zauważyć ciekawy wizualny efekt - klocki wydają się być położone maksymalnie pionowo.
Wynika to z faktu, że takie położenie minimalizuje wysokość w danym ruchu - nie ma znaczenia, że za kilka ruchów może się okazać niekorzystne.

\begin{figure}[H]
\includegraphics[width=\textwidth]{wysokosc.PNG}
\caption{Ułożenie klocków dla funkcji wysokości}
\end{figure}

\item Funkcja maksymalizująca przyleganie

Gęstość dla $k=3$: 76

Najlepsza gęstość dla $k=8$: 83

Funkcja przylegania sprawdziła się w tym przypadku najlepiej.

\begin{figure}[H]
\includegraphics[width=\textwidth]{przyleglosc.PNG}
\caption{Ułożenie klocków dla funkcji przyległości}
\end{figure}

\end{enumerate}
\subsubsection{Szerokość studni: 80}
\begin{enumerate}

\item Funkcja minimalizująca dziury

Gęstość dla $k=3$: 66

Najlepsza gęstość dla $k=5$: 71

\begin{figure}[H]
\includegraphics[width=\textwidth]{szeroka_plansza.PNG}
\caption{Ułożenie klocków dla funkcji przyległości}
\end{figure}

\item Funkcja minimalizująca wysokość

Gęstość dla $k=3$: 66

Najlepsza gęstość dla $k=9$: 66

\item Funkcja maksymalizująca przyleganie

Gęstość dla $k=3$: 66

Najlepsza gęstość dla $k=5$: 71

\end{enumerate}
\textbf{Wnioski}
W tym teście najlepsza okazała się funkcja przylegania, jednak niewiele tylko wyprzedziła funkcję dziur.

Warto zauważyć, że algorytm daje najlepsze wyniki dla średniej szerokości studni, co zgadza się z intuicją.
W przypadku małej szerokości, porównywalnej z szerokością niektórych klocków trudno jest osiągnąć dobre zapełnienie dziur - w niektórych momentach konieczne jest praktycznie układanie klocków jeden na drugim.
Z kolei przy szerokiej studni na wynik niekorzystnie wpływają górne mało zapełnione wiersze.
%\subsection{zestaw drugi...}
\section{Wnioski} %z testów
\end{document}